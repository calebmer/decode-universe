import { Set, OrderedSet } from 'immutable';
import { Observable } from 'rxjs';
import { PeerStreams } from './PeerStreams';

/**
 * The configuration we use when creating `RTCPeerConnection` instances.
 *
 * There are some free STUN servers available to us. Let’s use them!
 */
const rtcConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
  ],
};

/**
 * A single peer that we communicate with over the course of our application’s
 * lifecycle.
 *
 * The peer is considered “open” on construction, and it can be closed with
 * `close()`.
 *
 * This class is not responsible for negotiations with the peer. That is the
 * responsibility of classes like `PeersMesh` or other orchestrators. This class
 * does all of the actual work required to communicate data between the peers,
 * but does not negotiate.
 */
export class Peer {
  /**
   * The DOM API object for the connection that we make with our peer.
   */
  public readonly connection: RTCPeerConnection;

  /**
   * All of the remote media streams that our peer has given us access to. As
   * the peer may add and remove streams over time this is an observable.
   */
  public readonly remoteStreams: Observable<OrderedSet<MediaStream>>;

  /**
   * Disposables that are to be disposed of when we close the peer.
   */
  private disposables: Array<{ dispose: () => void }> = [];

  constructor({
    localStreams,
  }: {
    localStreams: Observable<Set<MediaStream>>,
  }) {
    // Create a new connection using the pre-defined config.
    this.connection = new RTCPeerConnection(rtcConfig);

    // Make sure to have a lazy observable ready for all of the remote streams
    // we expect to be generated by this peer.
    this.remoteStreams = PeerStreams.watchRemoteStreams(this.connection);

    // Maintain all of the local streams in accordance to the observable we were
    // given.
    this.disposables.push(PeerStreams.maintainLocalStreams(
      this.connection,
      localStreams,
    ));
  }

  /**
   * Closes the peer be closing the connection and disposing any other resources
   * created to communicate with the peer.
   */
  public close(): void {
    // Disposes all of our disposables.
    this.disposables.forEach(disposable => disposable.dispose());
    this.disposables = [];
    // If the connection is not already closed then close it.
    if (this.connection.signalingState !== 'closed') {
      this.connection.close();
    }
  }
}
